# SPFA(Shortest Path Faster Algorithm)
 - 벨만 포드 알고리즘의 확장 알고리즘

## 벨만 - 포드 
- 모든 간선을 V - 1번 쭉 훌음
- SPFA는 거리 갱신이 실제로 일어난 정점에서 나가는 간선만 봄
  - 즉, 큐에 이번에 값이 줄어든 정점만 넣고, 그 정점에서만 relax(완화)를 반복해 불필요한 간선 스캔을 줄임

relax(완화)란?
- 정의 : 어떤 간선(u -> v, 가중치 w)를 이용해서 현재 알고 있는 dist[v] (시작점에서 v까지의 최단거리)보다 dist[u] + w 가 더 짧다면, v까지의 최단거리 정보를 갱신하는 과정을 말함.

왜 필요?

- 알고리즘(다익스트라, 벨만포드, SPFA)은 모든 간선을 반복적으로 relax해서,
시작점에서 다른 정점으로 가는 최단 경로를 찾음

직관:

- “u까지 이렇게 왔는데, v로 가는 더 싸고 좋은 길을 찾았네? → 기존 기록보다 싸면 갈아끼운다.”

## 동작 절차
1. dist[] = INF, dist[S] = 0, intQ[] = false, cnt[] = 0
2. S를 큐에 넣고 시작
3. 큐에서 U를 꺼내 inQ[u]=false
4. u -> v 모든 간선에 대해 dist[v] > dist[u]+w 이면 갱신하고, v가 큐에 없으면 큐에 넣음
5. 큐가 빌때까지 반복
6. cnt[v] >= V 면 음수 사이클 의심

### S(Source)
- 의미 : 최단 경로 알고리즘을 시작하는 출발 정점
- 보통 dist[S] = 0으로 두고, 나머지는 INF로 초기화

예) 책 구매 문제 : 서점들의 공급을 연결하는 출발 노드가 소스
   - S -> 각 서점 으로 간선을 두고, 서점 재고만큼 용량을 줌

종착점은 보통 T(Sink)라고 부름
예) 책 구매 문제에서 사람들의 수요를 모두 연결한 마지막 노드가 sink


## 시간 복잡도
- 최악 : O(VE) - 이론상 벨만-포드와 동일
- 평균 : 매우 빠른편

## 왜 MCMP(Min-Cost Max-Flow)에 잘맞는가?
- 잔여 그래프에는 역간선 비용이 음수가 생기므로 단독 사용이 곤란함.
- SPFA는 음수 간선을 다룰 수 있음.
  - 증가경로의 최소비용을 바로 찾음.